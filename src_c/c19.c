

#include <stdio.h>

int changer(int a) {
    a += 5;
    return a;
}

// 8바이트
int main(void) {
    int i = 30;

    // 수정가능지역 시작
    int *p1;
    p1 = &i;
    *p1 = 50;



    // 수정가능지역 끝

    printf("i : %d\n", i);

    // 출력 => i : 50
    i = changer(i);
    // 수정가능지역 끝

    printf("i : %d\n", i);
/*Dump of assembler code for function changer:
   0x0000000000001169 <+0>:	endbr64 
   0x000000000000116d <+4>:	push   %rbp
   0x000000000000116e <+5>:	mov    %rsp,%rbp
   0x0000000000001171 <+8>:	mov    %edi,-0x4(%rbp)
   0x0000000000001174 <+11>:	addl   $0x5,-0x4(%rbp)
   0x0000000000001178 <+15>:	mov    -0x4(%rbp),%eax
   0x000000000000117b <+18>:	pop    %rbp
   0x000000000000117c <+19>:	ret    
End of assembler dump.
changer  함수의 스택공간에서 차지 용량 0x117c - 0x1169 = 0x13(19bytes)
*/
    printf("%d\n",(int)sizeof(p1));

    // 포인터가 스택에 차지하는 용량 8 byte 
    // 주소를 저장하고 수정하는 포인터 방식이 함수에 배해 훨신 메모리 효율성이 좋다.(데이터의 복사, 불필요한 선언등을 하지 않는다)
    // 물론 전역변수가(함수에서 선언한 변수가 아니다) 더 좋은 메모리 효율성을(8byte 아낀다+alpha) 같지만 변형이 쉬워 값이 손상되기 쉽다.
    // 스택은 함수간 독립적이다.
    // 출력 => i : 50

/*포인터의 메모리공간이 8byte여도 충분한 이유
 메모리 공간은 16기가바이트라는 큰 공간을 갖지만, 메모리 매핑을 통해 작은
 그룹(페이지)으로 나눌 수 있음
 64bit 시스템에서 메모리 주소는 16 엑사바이트 내에 있음
 16 엑사바이트내의 수는 모두 8바이트내에서 해결 가능
 따라서 64비트 시스템에서 포인터의 크기는 8바이트임
 */
/*
왜 포인터 식별자와 변수의 식별자를 맞춰야 하는가?
데이터를 읽는 방식(4byte(32bit)의 주소공가능로 읽고 부동 소수점으로 해석(float))
포인터의 역참조나 연산시 변수 크기에 따른 다른 해석

void * p = &a
를 사용할 수 있으나

이러면 역참조시 특정 자료형으로 명시적 캐스팅을 해야함
*(int*)ptr
*/
    return 0;
}
